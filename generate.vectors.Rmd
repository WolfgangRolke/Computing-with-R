---
header-includes: \usepackage{color}
output:
  html_document: default
  pdf_document:
    fig_caption: no
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
whichcomp <- strsplit(getwd(),"/")[[1]][3]
load(paste0("c:/users/", whichcomp, "/Dropbox/Resma3/Resma3.RData"))

require(knitr)
require(ggplot2)
require(grid)
require(leaps)
```
`r rmd$basefontsize()`

<style>
table, th, td { text-align:right; }
th, td {padding: 10px;}
</style>

#Generating Vectors

There are numerous ways to generate vectors which have some structure. Here are some useful commands

The easiest way to do this is to use the *c* command:

```{r}
x <- c(0, 2, 3, 1, 5)
x
```

to make sequences us *:*

```{r}
1:5
-2:2
```

and then we can combine these:

```{r}
c(1:5, 11:15)
```

`r rmd$vspace()`

there are also a number of commands for this purpose:

-  seq

```{r}
seq(1, 10, 1)
seq(1, 10, 1/2)
seq(0, 10, length=20)
```

-  sequence

this creates a series of sequences of integers each ending by the numbers given as arguments:


```{r}
sequence(1:5)
```

-  rep

```{r}
rep(1, 10)
rep(1:3, 10)
rep(1:3, each=3)
rep(c("A", "B", "C"), c(4, 7, 3))
```

what does this do?

```{r, eval=FALSE}
rep(1:10, 1:10)
```

-  gl

The function *gl* (generate levels) is very useful because it generates regular series of factors. The usage of this fonction is gl(k, n) where k is the number of levels (or classes), and n is the number of replications in each level. Two options may be used: length to specify the number of data produced, and labels to specify the names of the levels of the factor. 

```{r}
gl(3, 5)
gl(3, 5, length=30)
gl(2, 6, label=c("Male", "Female"))
gl(2, 10)
gl(2, 1, length=20)
```

-  expand.grid

this takes a couple of vectors and writes them as a matrix with each combination.

```{r}
expand.grid(1:2, 1:3)
expand.grid(First=1:2, Second=1:3, Third=c("A", "B"))
```

there are anumber of R routines who need the data in this format as arguments, so this is an easy way to convert them.

##Expressions

up to now we discussed how to generate data objects. Soon we will be talking about how to write your own functions. There is however also a type of object somewhat in between, so called expressions.

An expression is a series of characters which make sense for R. All valid commands are expressions. When a command is typed directly on the keyboard, it is then evaluated by R and executed if it is valid. In many circumstances, it is useful to construct an expression without evaluating it: this is what the function expression is made for. It is, of course, possible to evaluate the expression subsequently with eval().

```{r}
x <- 3; y <- 2.5; z <- 1 
exp1 <- expression(x / (y + exp(z))) 
exp1 
eval(exp1) 
```

Expressions can be used for many things. Here are two examples:

I want to draw the graph of a function, including the equation:

```{r}
curve(x^2*exp(-x^2), -2, 2, main=expression(x^2*exp(-x^2)), ylab="")
```


An expression can be created from a variable of mode character. Some functions take expressions as arguments, for example D which returns partial derivatives:

```{r}
D(exp1, "x")
eval(D(exp1, "x"))
D(exp1, "y")
eval(D(exp1, "y"))
D(exp1, "z")
eval(D(exp1, "z"))
```

