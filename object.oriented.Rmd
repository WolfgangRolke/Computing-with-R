---
header-includes: \usepackage{color}
output:
  html_document: default
  pdf_document:
    fig_caption: no
---

<style>
table, th, td { text-align:right; }
th, td {padding: 10px;}
</style>

```{r, echo=FALSE, warning=FALSE, message=FALSE}
whichcomp <- strsplit(getwd(),"/")[[1]][3]
load(paste0("c:/users/", whichcomp, "/Dropbox/teaching/Resma3/Resma3.RData"))
require(knitr)
require(ggplot2)
require(grid)
```
`r hl()$basefontsize()`

#Object-Oriented Programming

Like C++ and just about every other modern programming language R is *object oriented*. This is huge topic and we will only discuss the basic ideas. It is also only worth while (and in fact absolutely necessary) when writing large programs, at least several 100 lines.

We start with the following:

```{r}
x <- rnorm(100)
a <- ecdf(x)
plot(a)
a <- density(x)
plot(a)
```

so also we call the same command (plot) we get different graphs, one of the empirical distribution function and the other a non-parametric density estimate.

But how does R know what to do in either case? The reason is that each object has a class property:

```{r}
a <- ecdf(x)
class(a)
a <- density(x)
class(a)
```

There are also many different plot functions (or methods)

```{r}
methods(plot)
```

so what happens is that when we call plot with some object R examines its class property, and the picks the specific plot method that corresponds to it. 

R actually has three different ways to use object-oriented programming, called S3, S4 and RC. We won't go into the details and which of them is more useful under what circumstances. In the following examples we use S3, which is the easiest to use but also usually sufficient.

Say we work for a store. At the end of each day we want to create a short report that 

-  gives the number of sales, their mean and standard deviation for each salesperson.  
-  does a boxplot of the sales, grouped by salesperson

Say the data is in a dataframe where the first column is the amount of a sale and the second column identifies the salesperson. So it might look like this:

```{r echo=FALSE}
x <- round(rchisq(40, 4)*10, 2)
salesperson <- c("Jack", "Jim", "Mary", "Ann")
z <- factor(sample(salesperson, size=40, replace=T), 
        levels = salesperson, ordered = TRUE)
sales.data <- data.frame(Sales=x, Salesperson=z)
kable(sales.data[1:5,])
```

Here is the non-object oriented solution:

```{r}
report <- function(dta) {
  salespersons <- unique(dta$Salesperson) 
  tbl <- matrix(0, length(salespersons), 3)
  rownames(tbl) <- salespersons
  colnames(tbl) <- c("Sales", "Mean", "SD")
  tbl[, 1] <- tapply(dta$Sales, dta$Salesperson, length)
  tbl[, 2] <- round(tapply(dta$Sales, dta$Salesperson, mean), 2)
  tbl[, 3] <- round(tapply(dta$Sales, dta$Salesperson, sd), 2)
  print(tbl)
  boxplot(dta$Sales~dta$Salesperson, horizontal=TRUE)
}
report(sales.data)
```

Here is the object oriented one. First we have to define a new class:

```{r}
as.sales <- function(x) {
  class(x) <- "sales"
  return(x)
}
```

Next we have to define the methods:

```{r}
stats <- function(x) UseMethod("stats")
stats.sales <- function(dta) {
  salespersons <- unique(dta$Salesperson)
  tbl <- matrix(0, length(salespersons), 3)
  rownames(tbl) <- salespersons
  colnames(tbl) <- c("Sales", "Mean", "SD")
  tbl[, 1] <- tapply(dta$Sales, dta$Salesperson, length)
  tbl[, 2] <- round(tapply(dta$Sales, dta$Salesperson, mean), 2)
  tbl[, 3] <- round(tapply(dta$Sales, dta$Salesperson, sd), 2)
  tbl
}
```

```{r}
plot <- function(x) UseMethod("plot")
plot.sales <- function(dta) 
  boxplot(dta$Sales~dta$Salesperson, horizontal=TRUE)
```

and now we can run

```{r}
sales.data <- as.sales(sales.data)
stats(sales.data)
plot(sales.data)
```

So far not much has been gained. But let's say that sometimes we also have information on the whether the sales person was on the morning or on the afternoon shift, and we want to include this in our report. One great feature of object-oriented programing is *inheritance*, that is we can define a new class that already has all the features of the old one, plus whatever new one we want.

so say now the data is

```{r, echo=FALSE}
tms <- c("Morning", "Afternoon")
u <-  factor(sample(tms, size=40, replace=T), 
        levels = tms, ordered = TRUE)
sales.time.data <- data.frame(Sales=x, Salesperson=z, Time=u)
kable(sales.time.data[1:5, ])
```

```{r error=T}
class(sales.time.data) <- c("salestime", "sales")
plot(sales.time.data)
```

and so we see that because sales.data is also of class sales plot still works. But we can also define its own plot method:

```{r error=T}
plot <- function(x) UseMethod("plot")
plot.salestime <- function(dta) {
  par(mfrow=c(1,2))
  Sales <- dta$Sales[dta$Time=="Morning"]
  Salesperson <- dta$Salesperson[dta$Time=="Morning"]
  boxplot(Sales~Salesperson, main="Morning")
  Sales <- dta$Sales[dta$Time=="Afternoon"]
  Salesperson <- dta$Salesperson[dta$Time=="Afternoon"]
  boxplot(Sales~Salesperson, main="Afternoon")
  
}
plot(sales.time.data)
```

generally every class has at least three methods:

-  print  
-  summary (stats)  
-  plot


