---
header-includes: \usepackage{color}
output:
  html_document: default
  pdf_document:
    fig_caption: no
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
whichcomp <- strsplit(getwd(),"/")[[1]][3]
load(paste0("c:/users/", whichcomp, "/Dropbox/Resma3/Resma3.RData"))

require(knitr)
require(ggplot2)
require(grid)
require(leaps)
```
`r rmd$basefontsize()`

<style>
table, th, td { text-align:right; }
th, td {padding: 10px;}
</style>

#Data Input/Output, Transfering R Objects

##Printing Info to Screen

The basic functions to display information on the screen are

```{r echo=-1}
x <- runif(10)
x
print(x)
cat(x)
```

Both of these have certain advantages:

-  with print you can control the amount of rounding

```{r}
print(x, 2)
```

-  with cat you can easily mix text and numeric:

```{r}
cat("The mean is :", round(mean(x), 2), "\n")
```

The "\\n" is needed so that the cursor moves to the next line.

Some times you need a high level of control over the output, for example when writting data to a file that then will be read by a computer program that want things just so. For this you can use the *sprintf* command.

```{r}
sprintf("%f", pi)
sprintf("%.3f", pi)
sprintf("%1.0f", pi)
sprintf("%5.1f", pi)
sprintf("%05.1f", pi)
sprintf("%+f", pi)
sprintf("% f", pi)
```

Here is another example. In Statistics we often find a p value. These should generally be quoted to three digits. But when the p value is less than $10^{-3}$ R uses scientific notation. If you want to avoid that do this

```{r}
p <- c(0, 0.0001)
p
sprintf("%.3f", p)
```

##Vectors

Often the easiest thing to do is to use copy-paste on a vector and then simply *scan* it into R:

```{r eval=FALSE}
x <- scan("clipboard")
```

-  use the argument sep=";" to change the symbol that is being use as a spearator. The default is empty space, common cases include  commas and newline (\\n)  

-  scan assumes that the  data is numerci, if not use the argument what="char".

I need to do this so often I wrote a little routine for it:

```{r}
getx <- function(sep="") {
  options(warn=-1)
  x <- scan("clipboard", what="character", sep=sep)
  if(all(!is.na(as.numeric(x))))
    x <- as.numeric(x)
  options(warn=0)
  x  
}
```

Notice some features:

-  the routine always reads the data as character vector, whether it is character or numeric.

-  it then tries to turn it into numeric. If that works, fine, otherwise it stays character. This is done with as.numeric(x), which returns NA if it can't turn an entry into numeric, so is.na(as.numeric(x)) returns TRUE if x can't be made numeric.

-  when trying to turn a character into a number R prints a warning. This is good in general to warn you that you are doing something strange. Here, so it is expected behaviour and we don't need the warning. The routine suppresses them by setting options(warn=-1), and setting it back to the default afterwards.

If the data is in a stand-alone file saved on your hard drive you can also read it from there:

```{r eval=FALSE}
x <- scan("c:\\folder\\file.R")
```


Notice the use of / in writing folders. \\ does not work on Windows because it is already used for other things.

scan has a lot of arguments:

```{r}
args(scan)
```

##Data Frames

the standard command to read data froma table into a data frame is *read.table*. 

```{r eval=FALSE}
x <- read.table("c:/folder/file.R")
```

it has many of the same arguments as scan (for example sep). It also has the argument header=FALSE. If your table has column names use header=TRUE. The same for row names.

Example: say the following data is saved in a file named *student.data.R*:

```{r, echo=6}
set.seed(111)
ID <- sample(10000:99999, size=10)
Age <- sample(18:25, size=10, replace=T)
GPA <- round(runif(10, 2, 4), 1)
Gender <- sample(c("Male", "Female"), size=10, replace=T)
students <- data.frame(ID, Age, GPA, Gender)
knitr::kable(students)
```

Now we can use

```{r eval=FALSE}
read.table("c:/folder/student.data.R", header=TRUE, row.names = 1)
```

the row.names=1 tells R to use the firs column as row names.

##Transfering Objects from one R to Another

Say you have a few data sets and routine you want to send to someone else. The easiest thing to do is use *dump* and *source*.

```{r eval=FALSE}
dump(c("data1", " data2", "fun1"), "c:/folder/mystuff.R")
```

Now to read in the stuff simply use

```{r eval=FALSE}
source("c:/folder/mystuff.R")
```


##Special File Formats

There are routines to read all sorts of file formats. The most important one is likely *read.csv*, which can read Excel files saved in the comma delimited format.

##Packages

there are a number of packages written to help with data I/O. We will discuss some of them later.

##Working on Files

R can also be used to create, copy, move and delete files on your hard drive. The routine are

file.create(..., showWarnings = TRUE)  
file.exists(...)  
file.remove(...)  
file.rename(from, to)  
file.append(file1, file2)  
file.copy(from, to)  

You can also get a listing of the files in a folder:

```{r}
head(dir("c:/R"))
```

for the folder from which R started use

```{r}
head(dir(getwd()))
```
