---
header-includes: \usepackage{color}
output:
  html_document: default
  pdf_document:
    fig_caption: no
---

<style>
table, th, td { text-align:right; }
th, td {padding: 10px;}
</style>

```{r, echo=FALSE, warning=FALSE, message=FALSE}
whichcomp <- strsplit(getwd(),"/")[[1]][3]
load(paste0("c:/users/", whichcomp, "/Dropbox/Resma3/Resma3.RData"))
library(knitr)
opts_chunk$set(fig.width=6, fig.align = "center", 
      out.width = "70%", warning=FALSE, message=FALSE)
library(ggplot2)
library(grid)
```
`r hl()$basefontsize()`


#Data Input/Output, Transfering R Objects

##Printing Info to Screen

The basic functions to display information on the screen are

```{r echo=-1}
x <- runif(10)
print(x)
cat(x)
```

Both of these have certain advantages:

-  with print you can control the amount of rounding

```{r}
print(x, 2)
```

-  with cat you can easily mix text and numeric:

```{r}
cat("The mean is :", round(mean(x), 2), "\n")
```

The "\\n" is needed so that the cursor moves to the next line.

Some times you need a high level of control over the output, for example when writing data to a file that then will be read by a computer program that wants things just so. For this you can use the *sprintf* command.

```{r}
sprintf("%f", pi)
sprintf("%.3f", pi)
sprintf("%1.0f", pi)
sprintf("%5.1f", pi)
sprintf("%05.1f", pi)
sprintf("%+f", pi)
sprintf("% f", pi)
```

Here is another example. In Statistics we often find a p value. These should generally be quoted to three digits. But when the p value is less than $10^{-3}$ R uses scientific notation. If you want to avoid that do this

```{r}
p <- c(0, 0.213, 0.0001)
p
sprintf("%.3f", p)
```

##Vectors

Often the easiest thing to do is to use copy-paste on a vector and then simply *scan* it into R:

```{r eval=FALSE}
x <- scan("clipboard")
```

-  use the argument sep=";" to change the symbol that is being use as a separator. The default is empty space, common cases include  commas and newline (\\n)  

-  scan assumes that the  data is numeric, if not use the argument what="char".

I need to do this so often I wrote a little routine for it:

```{r}
getx <- function(sep="") {
  options(warn=-1) #It might give a warning, I don't care
  x <- scan("clipboard", what="character", sep=sep)
  if(all(!is.na(as.numeric(x)))) #are all elements numeric?
    x <- as.numeric(x) #then make it numeric
  options(warn=0)
  x  
}
```

Notice some features:

-  the routine always reads the data as character vector, whether it is character or numeric.

-  it then tries to turn it into numeric. If that works, fine, otherwise it stays character. This is done with as.numeric(x), which returns NA if it can't turn an entry into numeric, so is.na(as.numeric(x)) returns TRUE if x can't be made numeric.

-  when trying to turn a character into a number R prints a warning. This is good in general to warn you that you are doing something strange. Here, so it is expected behaviour and we don't need the warning. The routine suppresses them by setting options(warn=-1), and setting it back to the default afterwards.

If the data is in a stand-alone file saved on your hard drive you can also read it from there:

```{r eval=FALSE}
x <- scan("c:/folder/file.R")
```

Notice the use of / in writing folders. \\ does not work on Windows because it is already used for other things, \\\\ would work but is more work to type!

scan has a lot of arguments:

```{r}
args(scan)
```

the most useful are 

-  what  
-  sep  
-  nmax maximum number of lines to read, useful if you don't know just how large the file is and want to read just some of it to check it out  
-  skip  number of lines at beginning to skip, for example if there is some header.  
-  quiet=FALSE  by default R will say how many lines have been read, this can be a nuisance if you have a routine that reads in many files.  
-  blank.lines.skip=TRUE  does not read in empty lines. This is a problem if you want to write the file out again later and want it to look as much as possible like the original. 


##Data Frames

the standard command to read data from a table into a data frame is *read.table*. 

```{r eval=FALSE}
x <- read.table("c:/folder/file.R")
```

it has many of the same arguments as scan (for example sep). It also has the argument header=FALSE. If your table has column names use header=TRUE. The same for row names.

Example: say the following data is saved in a file named *student.data.R*:

```{r, echo=6}
set.seed(111)
ID <- sample(10000:99999, size=10)
Age <- sample(18:25, size=10, replace=T)
GPA <- round(runif(10, 2, 4), 1)
Gender <- sample(c("Male", "Female"), size=10, replace=T)
students <- data.frame(ID, Age, GPA, Gender)
knitr::kable(students)
```

Now we can use

```{r eval=FALSE}
read.table("c:/folder/student.data.R", 
        header=TRUE, row.names = 1)
```

the row.names=1 tells R to use the first column as row names.

##Transfering Objects from one R to another

Say you have a few data sets and routines you want to send to someone else. The easiest thing to do is use *dump* and *source*.

```{r eval=FALSE}
dump(c("data1", " data2", "fun1"), "c:/folder/mystuff.R")
```

Now to read in the stuff simply use

```{r eval=FALSE}
source("c:/folder/mystuff.R")
```

I do this a lot, so I wrote myself these two routines:

```{r}
dp <- function (x) dump(x, "clipboard")
sc <- function () source("clipboard")
```

##Special File Formats

There are routines to read all sorts of file formats. The most important one is likely *read.csv*, which can read Excel files saved in the comma delimited format.

##Packages

there are a number of packages written to help with data I/O. We will discuss some of them later.

##Working on Files

R can also be used to create, copy, move and delete files and folders on your hard drive. The routines are

dir.create(...)  
dir.exists(...)  
file.create(...)  
file.exists(...)  
file.remove(...)  
file.rename(from, to)  
file.append(file1, file2)  
file.copy(from, to)  

You can also get a listing of the files in a folder:

```{r}
head(dir("c:/R"))
```

for the folder from which R started use

```{r}
head(dir(getwd()))
```
